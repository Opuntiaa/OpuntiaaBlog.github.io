<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://vuepress-theme-hope-demo.mrhope.site/rss.xml" rel="self" type="application/rss+xml"/>
    <title>仙人掌掌</title>
    <link>https://vuepress-theme-hope-demo.mrhope.site/</link>
    <description>大人虎变，君子豹变</description>
    <language>en-US</language>
    <pubDate>Tue, 12 Apr 2022 02:40:28 GMT</pubDate>
    <lastBuildDate>Tue, 12 Apr 2022 02:40:28 GMT</lastBuildDate>
    <generator>@mr-hope/vuepress-plugin-feed</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <item>
      <title>删除排序数组中的重复项</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/1.%E5%BF%AB%E6%85%A2%E5%8F%8C%E6%8C%87%E9%92%88.html</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/1.%E5%BF%AB%E6%85%A2%E5%8F%8C%E6%8C%87%E9%92%88.html</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">删除排序数组中的重复项</source>
      <pubDate>Mon, 11 Apr 2022 16:35:43 GMT</pubDate>
      <content:encoded><![CDATA[<h4 id="题目"> 题目：</h4>
<p><img src="/image/104045.png" alt="image-20220221104316467" loading="lazy"></p>
<h4 id="解"> 解：</h4>
<p><strong>快慢双指针解决</strong>
使用两个指针，右指针始终往右移动，</p>
<p>如果右指针指向的值等于左指针指向的值，左指针不动。
如果右指针指向的值不等于左指针指向的值，那么左指针往右移一步，然后再把右指针指向的值赋给左指针。</p>
<div><pre><code><span>public</span> <span>int</span> <span>removeDuplicates</span><span>(</span><span>int</span><span>[</span><span>]</span> <span>A</span><span>)</span> <span>{</span>
        <span>//边界条件判断</span>
        <span>if</span> <span>(</span><span>A</span> <span>==</span> <span>null</span> <span>||</span> <span>A</span><span>.</span>length <span>==</span> <span>0</span><span>)</span>
            <span>return</span> <span>0</span><span>;</span>
        <span>int</span> left <span>=</span> <span>0</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> right <span>=</span> <span>1</span><span>;</span> right <span>&lt;</span> <span>A</span><span>.</span>length<span>;</span> right<span>++</span><span>)</span>
            <span>//如果左指针和右指针指向的值一样，说明有重复的，</span>
            <span>//这个时候，左指针不动，右指针继续往右移。如果他俩</span>
            <span>//指向的值不一样就把右指针指向的值往前挪</span>
            <span>if</span> <span>(</span><span>A</span><span>[</span>left<span>]</span> <span>!=</span> <span>A</span><span>[</span>right<span>]</span><span>)</span>
                <span>A</span><span>[</span><span>++</span>left<span>]</span> <span>=</span> <span>A</span><span>[</span>right<span>]</span><span>;</span>
        <span>return</span> <span>++</span>left<span>;</span>
    <span>}</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div>]]></content:encoded>
      <enclosure url="https://vuepress-theme-hope-demo.mrhope.site/image/104045.png" type="image/png"/>
    </item>
    <item>
      <title>整数反转</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/10.%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC.html</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/10.%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC.html</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">整数反转</source>
      <pubDate>Mon, 11 Apr 2022 16:35:43 GMT</pubDate>
      <content:encoded><![CDATA[<h3 id="整数反转"> 整数反转</h3>
<h4 id="题目-屏幕截图-2022-03-12-091546-e-aa-课件笔记源码资料-1-aaaaaaaaaaaaaaa基础理论-数据结构与算法-image-屏幕截图-2022-03-12-091546-png"> 题目：![屏幕截图 2022-03-12 091546](E:\AA 课件笔记源码资料\1.AAAAAAAAAAAAAAA基础理论\数据结构与算法\image\屏幕截图 2022-03-12 091546.png)</h4>
<h4 id="解-与"> 解：/与%</h4>
<div><pre><code>

    <span>public</span> <span>int</span> <span>reverse</span><span>(</span><span>int</span> x<span>)</span> <span>{</span>
        <span>long</span> res <span>=</span> <span>0</span><span>;</span>
        <span>while</span> <span>(</span>x <span>!=</span> <span>0</span><span>)</span> <span>{</span>
            res <span>=</span> res <span>*</span> <span>10</span> <span>+</span> x <span>%</span> <span>10</span><span>;</span>
            x <span>/=</span> <span>10</span><span>;</span>
        <span>}</span>
        <span>return</span> <span>(</span><span>int</span><span>)</span> res <span>==</span> res <span>?</span> <span>(</span><span>int</span><span>)</span> res <span>:</span> <span>0</span><span>;</span>
    <span>}</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>字符串中的第一个唯一字符</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/11.map.getOrDefault.html</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/11.map.getOrDefault.html</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">字符串中的第一个唯一字符</source>
      <pubDate>Mon, 11 Apr 2022 16:35:43 GMT</pubDate>
      <content:encoded><![CDATA[<h3 id="字符串中的第一个唯一字符"> 字符串中的第一个唯一字符</h3>
<h4 id="题目"> 题目：</h4>
<p>![屏幕截图 2022-03-13 165652](E:\AA 课件笔记源码资料\1.AAAAAAAAAAAAAAA基础理论\数据结构与算法\image\屏幕截图 2022-03-13 165652.png)</p>
<h4 id="解-map-getordefault"> 解：map.getOrDefault</h4>
<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>
    <span>public</span> <span>int</span> <span>firstUniqChar</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>
        <span>Map</span><span><span>&lt;</span><span>Character</span><span>,</span><span>Integer</span><span>></span></span> map<span>=</span><span>new</span> <span>HashMap</span><span>(</span><span>)</span><span>;</span>
        <span>char</span><span>[</span><span>]</span> chars<span>=</span>s<span>.</span><span>toCharArray</span><span>(</span><span>)</span><span>;</span>
        <span>for</span><span>(</span><span>char</span> c <span>:</span> chars<span>)</span><span>{</span>
            map<span>.</span><span>put</span><span>(</span>c<span>,</span>map<span>.</span><span>getOrDefault</span><span>(</span>c<span>,</span><span>0</span><span>)</span><span>+</span><span>1</span><span>)</span><span>;</span>
        <span>}</span>
        <span>for</span><span>(</span><span>int</span> i <span>=</span><span>0</span><span>;</span>i<span>&lt;</span>chars<span>.</span>length<span>;</span>i<span>++</span><span>)</span><span>{</span>
            <span>if</span><span>(</span>map<span>.</span><span>get</span><span>(</span>chars<span>[</span>i<span>]</span><span>)</span><span>==</span><span>1</span><span>)</span><span>{</span>
                <span>return</span> i<span>;</span>
            <span>}</span>
        <span>}</span>
        <span>return</span><span>-</span><span>1</span><span>;</span>

    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>有效的字母异位词</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/12.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F%E5%AF%B9%E6%AF%94.html</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/12.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F%E5%AF%B9%E6%AF%94.html</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">有效的字母异位词</source>
      <pubDate>Mon, 11 Apr 2022 16:35:43 GMT</pubDate>
      <content:encoded><![CDATA[<h3 id="有效的字母异位词"> 有效的字母异位词</h3>
<h4 id="题目"> 题目：</h4>
<p>![屏幕截图 2022-03-15 091110](E:\AA 课件笔记源码资料\1.AAAAAAAAAAAAAAA基础理论\数据结构与算法\image\屏幕截图 2022-03-15 091110.png)</p>
<h4 id="解-排序对比"> 解：排序对比</h4>
<div><pre><code>    <span>public</span> <span>boolean</span> <span>isAnagram</span><span>(</span><span>String</span> s<span>,</span> <span>String</span> t<span>)</span> <span>{</span>
        <span>char</span><span>[</span><span>]</span> sChar <span>=</span> s<span>.</span><span>toCharArray</span><span>(</span><span>)</span><span>;</span>
        <span>char</span><span>[</span><span>]</span> tChar <span>=</span> t<span>.</span><span>toCharArray</span><span>(</span><span>)</span><span>;</span>
        <span>//对两个字符串中的字符进行排序</span>
        <span>Arrays</span><span>.</span><span>sort</span><span>(</span>sChar<span>)</span><span>;</span>
        <span>Arrays</span><span>.</span><span>sort</span><span>(</span>tChar<span>)</span><span>;</span>
        <span>return</span> <span>Arrays</span><span>.</span><span>equals</span><span>(</span>sChar<span>,</span> tChar<span>)</span><span>;</span>
    <span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>验证回文串</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/13.%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2.html</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/13.%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2.html</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">验证回文串</source>
      <pubDate>Mon, 11 Apr 2022 16:35:43 GMT</pubDate>
      <content:encoded><![CDATA[<h3 id="验证回文串"> 验证回文串</h3>
<h4 id="题目"> 题目：</h4>
<p>![屏幕截图 2022-03-25 001228](E:\AA 课件笔记源码资料\1.AAAAAAAAAAAAAAA基础理论\数据结构与算法\image\屏幕截图 2022-03-25 001228.png)</p>
<h4 id="解-双指针-character-isletterordigit-判断是否为字母-数字-charat"> 解：双指针，Character.isLetterOrDigit（判断是否为字母，数字），charAt（）</h4>
<div><pre><code>    <span>public</span> <span>boolean</span> <span>isPalindrome</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>s<span>.</span><span>length</span><span>(</span><span>)</span> <span>==</span> <span>0</span><span>)</span>
            <span>return</span> <span>true</span><span>;</span>
        <span>int</span> left <span>=</span> <span>0</span><span>,</span> right <span>=</span> s<span>.</span><span>length</span><span>(</span><span>)</span> <span>-</span> <span>1</span><span>;</span>
        <span>while</span> <span>(</span>left <span>&lt;</span> right<span>)</span> <span>{</span>
            <span>//因为题中说了，只考虑字母和数字，所以不是字母和数字的先过滤掉</span>
            <span>while</span> <span>(</span>left <span>&lt;</span> right <span>&amp;&amp;</span> <span>!</span><span>Character</span><span>.</span><span>isLetterOrDigit</span><span>(</span>s<span>.</span><span>charAt</span><span>(</span>left<span>)</span><span>)</span><span>)</span>
                left<span>++</span><span>;</span>
            <span>while</span> <span>(</span>left <span>&lt;</span> right <span>&amp;&amp;</span> <span>!</span><span>Character</span><span>.</span><span>isLetterOrDigit</span><span>(</span>s<span>.</span><span>charAt</span><span>(</span>right<span>)</span><span>)</span><span>)</span>
                right<span>--</span><span>;</span>
            <span>//然后把两个字符变为小写，在判断是否一样，如果不一样，直接返回false</span>
            <span>if</span> <span>(</span><span>Character</span><span>.</span><span>toLowerCase</span><span>(</span>s<span>.</span><span>charAt</span><span>(</span>left<span>)</span><span>)</span> <span>!=</span> <span>Character</span><span>.</span><span>toLowerCase</span><span>(</span>s<span>.</span><span>charAt</span><span>(</span>right<span>)</span><span>)</span><span>)</span>
                <span>return</span> <span>false</span><span>;</span>
            left<span>++</span><span>;</span>
            right<span>--</span><span>;</span>
        <span>}</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>删除链表中的节点</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/15.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/15.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">删除链表中的节点</source>
      <pubDate>Mon, 11 Apr 2022 16:35:43 GMT</pubDate>
      <content:encoded><![CDATA[<h3 id="删除链表中的节点"> 删除链表中的节点</h3>
<h4 id="题目"> 题目：</h4>
<p>![屏幕截图 2022-04-04 215034](E:\AA 课件笔记源码资料\1.AAAAAAAAAAAAAAA基础理论\数据结构与算法\image\屏幕截图 2022-04-04 215034.png)</p>
<h4 id="解"> 解 ：</h4>
<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>
    <span>public</span> <span>void</span> <span>deleteNode</span><span>(</span><span>ListNode</span> node<span>)</span> <span>{</span>
        node<span>.</span>val <span>=</span> node<span>.</span>next<span>.</span>val<span>;</span>
        node<span>.</span>next <span>=</span> node<span>.</span>next<span>.</span>next<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>实现 strStr()</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/14.%E5%AE%9E%E7%8E%B0%20strStr().html</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/14.%E5%AE%9E%E7%8E%B0%20strStr().html</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">实现 strStr()</source>
      <pubDate>Mon, 11 Apr 2022 16:35:43 GMT</pubDate>
      <content:encoded><![CDATA[<h3 id="实现-strstr"> 实现 strStr()</h3>
<h4 id="题目"> 题目：</h4>
<p>![屏幕截图 2022-04-02 170908](E:\AA 课件笔记源码资料\1.AAAAAAAAAAAAAAA基础理论\数据结构与算法\image\屏幕截图 2022-04-02 170908.png)</p>
<h4 id="解-双指针"> 解：双指针</h4>
<div><pre><code>    <span>public</span> <span>int</span> <span>strStr</span><span>(</span><span>String</span> haystack<span>,</span> <span>String</span> needle<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>needle<span>.</span><span>length</span><span>(</span><span>)</span> <span>==</span> <span>0</span><span>)</span>
            <span>return</span> <span>0</span><span>;</span>
        <span>int</span> i <span>=</span> <span>0</span><span>;</span>
        <span>int</span> j <span>=</span> <span>0</span><span>;</span>
        <span>while</span> <span>(</span>i <span>&lt;</span> haystack<span>.</span><span>length</span><span>(</span><span>)</span> <span>&amp;&amp;</span> j <span>&lt;</span> needle<span>.</span><span>length</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>haystack<span>.</span><span>charAt</span><span>(</span>i<span>)</span> <span>==</span> needle<span>.</span><span>charAt</span><span>(</span>j<span>)</span><span>)</span> <span>{</span>
                i<span>++</span><span>;</span>
                j<span>++</span><span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                <span>//如果不匹配，就回退，从第一次匹配的下一个开始，</span>
                i <span>=</span> i <span>-</span> j <span>+</span> <span>1</span><span>;</span>
                j <span>=</span> <span>0</span><span>;</span>
            <span>}</span>
            <span>if</span> <span>(</span>j <span>==</span> needle<span>.</span><span>length</span><span>(</span><span>)</span><span>)</span>
                <span>return</span> i <span>-</span> j<span>;</span>
        <span>}</span>
        <span>return</span> <span>-</span><span>1</span><span>;</span>
    <span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>删除链表的倒数第N个节点</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/16.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.html</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/16.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.html</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">删除链表的倒数第N个节点</source>
      <pubDate>Mon, 11 Apr 2022 16:35:43 GMT</pubDate>
      <content:encoded><![CDATA[<h3 id="删除链表的倒数第n个节点"> 删除链表的倒数第N个节点</h3>
<h4 id="题目"> 题目：</h4>
<p><img src="/image/161901.png" alt="屏幕截图 2022-04-05 161901" loading="lazy"></p>
<h4 id="解"> 解：</h4>
<div><pre><code><span>public</span> <span>ListNode</span> <span>removeNthFromEnd</span><span>(</span><span>ListNode</span> head<span>,</span> <span>int</span> n<span>)</span> <span>{</span>
    <span>ListNode</span> pre <span>=</span> head<span>;</span>
    <span>int</span> last <span>=</span> <span>length</span><span>(</span>head<span>)</span> <span>-</span> n<span>;</span>
    <span>//如果last等于0表示删除的是头结点</span>
    <span>if</span> <span>(</span>last <span>==</span> <span>0</span><span>)</span>
        <span>return</span> head<span>.</span>next<span>;</span>
    <span>//这里首先要找到要删除链表的前一个结点</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> last <span>-</span> <span>1</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
        pre <span>=</span> pre<span>.</span>next<span>;</span>
    <span>}</span>
    <span>//然后让前一个结点的next指向要删除节点的next</span>
    pre<span>.</span>next <span>=</span> pre<span>.</span>next<span>.</span>next<span>;</span>
    <span>return</span> head<span>;</span>
<span>}</span>

<span>//求链表的长度</span>
<span>private</span> <span>int</span> <span>length</span><span>(</span><span>ListNode</span> head<span>)</span> <span>{</span>
    <span>int</span> len <span>=</span> <span>0</span><span>;</span>
    <span>while</span> <span>(</span>head <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        len<span>++</span><span>;</span>
        head <span>=</span> head<span>.</span>next<span>;</span>
    <span>}</span>
    <span>return</span> len<span>;</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div>]]></content:encoded>
      <enclosure url="https://vuepress-theme-hope-demo.mrhope.site/image/161901.png" type="image/png"/>
    </item>
    <item>
      <title>合并两个有序链表</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/17.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8.html</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/17.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8.html</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">合并两个有序链表</source>
      <pubDate>Mon, 11 Apr 2022 16:35:43 GMT</pubDate>
      <content:encoded><![CDATA[<h3 id="合并两个有序链表"> 合并两个有序链表</h3>
<h4 id="题目"> 题目：</h4>
<p><img src="/image/202759.png" alt="屏幕截图 2022-04-07 202759" loading="lazy"></p>
<h4 id="解"> 解：</h4>
<div><pre><code> <span>public</span> <span>ListNode</span> <span>mergeTwoLists</span><span>(</span><span>ListNode</span> list1<span>,</span> <span>ListNode</span> list2<span>)</span> <span>{</span>
       <span>//下面4行是空判断</span>
        <span>if</span> <span>(</span>list1 <span>==</span> <span>null</span><span>)</span>
            <span>return</span> list2<span>;</span>
        <span>if</span> <span>(</span>list2 <span>==</span> <span>null</span><span>)</span>
            <span>return</span> list1<span>;</span>
        <span>ListNode</span> dummy <span>=</span> <span>new</span> <span>ListNode</span><span>(</span><span>0</span><span>)</span><span>;</span>
        <span>ListNode</span> curr <span>=</span> dummy<span>;</span>
        <span>while</span> <span>(</span>list1 <span>!=</span> <span>null</span> <span>&amp;&amp;</span> list2 <span>!=</span> <span>null</span><span>)</span> <span>{</span>
            <span>//比较一下，哪个小就把哪个放到新的链表中</span>
            <span>if</span> <span>(</span>list1<span>.</span>val <span>&lt;=</span> list2<span>.</span>val<span>)</span> <span>{</span>
                curr<span>.</span>next <span>=</span> list1<span>;</span>
                list1 <span>=</span> list1<span>.</span>next<span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                curr<span>.</span>next <span>=</span> list2<span>;</span>
                list2 <span>=</span> list2<span>.</span>next<span>;</span>
            <span>}</span>
            curr <span>=</span> curr<span>.</span>next<span>;</span>
        <span>}</span>
        <span>//然后把那个不为空的链表挂到新的链表中</span>
        curr<span>.</span>next <span>=</span> list1 <span>==</span> <span>null</span> <span>?</span> list2 <span>:</span> list1<span>;</span>
        <span>return</span> dummy<span>.</span>next<span>;</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div>]]></content:encoded>
      <enclosure url="https://vuepress-theme-hope-demo.mrhope.site/image/202759.png" type="image/png"/>
    </item>
    <item>
      <title>回文链表</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/18.%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8.html</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/18.%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8.html</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">回文链表</source>
      <pubDate>Mon, 11 Apr 2022 16:35:43 GMT</pubDate>
      <content:encoded><![CDATA[<h3 id="回文链表"> 回文链表</h3>
<h4 id="题目"> 题目：</h4>
<p><img src="/image/215011.png" alt="屏幕截图 2022-04-07 215011" loading="lazy"></p>
<h4 id="解"> 解：</h4>
<h4 id="快慢指针-反转链表"> 快慢指针，反转链表</h4>
<div><pre><code><span>public</span> <span>boolean</span> <span>isPalindrome</span><span>(</span><span>ListNode</span> head<span>)</span> <span>{</span>
    <span>ListNode</span> fast <span>=</span> head<span>,</span> slow <span>=</span> head<span>;</span>
    <span>//通过快慢指针找到中点</span>
    <span>while</span> <span>(</span>fast <span>!=</span> <span>null</span> <span>&amp;&amp;</span> fast<span>.</span>next <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        fast <span>=</span> fast<span>.</span>next<span>.</span>next<span>;</span>
        slow <span>=</span> slow<span>.</span>next<span>;</span>
    <span>}</span>
    <span>//如果fast不为空，说明链表的长度是奇数个</span>
    <span>if</span> <span>(</span>fast <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        slow <span>=</span> slow<span>.</span>next<span>;</span>
    <span>}</span>
    <span>//反转后半部分链表</span>
    slow <span>=</span> <span>reverse</span><span>(</span>slow<span>)</span><span>;</span>

    fast <span>=</span> head<span>;</span>
    <span>while</span> <span>(</span>slow <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        <span>//然后比较，判断节点值是否相等</span>
        <span>if</span> <span>(</span>fast<span>.</span>val <span>!=</span> slow<span>.</span>val<span>)</span>
            <span>return</span> <span>false</span><span>;</span>
        fast <span>=</span> fast<span>.</span>next<span>;</span>
        slow <span>=</span> slow<span>.</span>next<span>;</span>
    <span>}</span>
    <span>return</span> <span>true</span><span>;</span>
<span>}</span>

<span>//反转链表</span>
<span>public</span> <span>ListNode</span> <span>reverse</span><span>(</span><span>ListNode</span> head<span>)</span> <span>{</span>
    <span>ListNode</span> prev <span>=</span> <span>null</span><span>;</span>
    <span>while</span> <span>(</span>head <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        <span>ListNode</span> next <span>=</span> head<span>.</span>next<span>;</span>
        head<span>.</span>next <span>=</span> prev<span>;</span>
        prev <span>=</span> head<span>;</span>
        head <span>=</span> next<span>;</span>
    <span>}</span>
    <span>return</span> prev<span>;</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><h4 id="栈解决"> 栈解决</h4>
<div><pre><code><span>public</span> <span>boolean</span> <span>isPalindrome</span><span>(</span><span>ListNode</span> head<span>)</span> <span>{</span>
    <span>ListNode</span> temp <span>=</span> head<span>;</span>
    <span>Stack</span><span><span>&lt;</span><span>Integer</span><span>></span></span> stack <span>=</span> <span>new</span> <span>Stack</span><span>(</span><span>)</span><span>;</span>
    <span>//把链表节点的值存放到栈中</span>
    <span>while</span> <span>(</span>temp <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        stack<span>.</span><span>push</span><span>(</span>temp<span>.</span>val<span>)</span><span>;</span>
        temp <span>=</span> temp<span>.</span>next<span>;</span>
    <span>}</span>

    <span>//然后再出栈</span>
    <span>while</span> <span>(</span>head <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>head<span>.</span>val <span>!=</span> stack<span>.</span><span>pop</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>return</span> <span>false</span><span>;</span>
        <span>}</span>
        head <span>=</span> head<span>.</span>next<span>;</span>
    <span>}</span>
    <span>return</span> <span>true</span><span>;</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div>]]></content:encoded>
      <enclosure url="https://vuepress-theme-hope-demo.mrhope.site/image/215011.png" type="image/png"/>
    </item>
    <item>
      <title>买卖股票的最佳时机</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/2.%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95.html</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/2.%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95.html</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">买卖股票的最佳时机</source>
      <pubDate>Mon, 11 Apr 2022 16:35:43 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="买卖股票的最佳时机"> 买卖股票的最佳时机</h1>
<h4 id="题目"> 题目：</h4>
<p><img src="/image/104045.png" alt="屏幕截图 2022-02-22 104045" loading="lazy"></p>
<h4 id="解"> 解：</h4>
<div><pre><code><span>public</span> <span>int</span> <span>maxProfit</span><span>(</span><span>int</span><span>[</span><span>]</span> prices<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>prices <span>==</span> <span>null</span> <span>||</span> prices<span>.</span>length <span>&lt;</span> <span>2</span><span>)</span>
        <span>return</span> <span>0</span><span>;</span>
    <span>int</span> total <span>=</span> <span>0</span><span>,</span> index <span>=</span> <span>0</span><span>,</span> length <span>=</span> prices<span>.</span>length<span>;</span>
    <span>while</span> <span>(</span>index <span>&lt;</span> length<span>)</span> <span>{</span>
        <span>//如果股票下跌就一直找，直到找到股票开始上涨为止</span>
        <span>while</span> <span>(</span>index <span>&lt;</span> length <span>-</span> <span>1</span> <span>&amp;&amp;</span> prices<span>[</span>index<span>]</span> <span>>=</span> prices<span>[</span>index <span>+</span> <span>1</span><span>]</span><span>)</span>
            index<span>++</span><span>;</span>
        <span>//股票上涨开始的值，也就是这段时间上涨的最小值</span>
        <span>int</span> min <span>=</span> prices<span>[</span>index<span>]</span><span>;</span>
        <span>//一直找到股票上涨的最大值为止</span>
        <span>while</span> <span>(</span>index <span>&lt;</span> length <span>-</span> <span>1</span> <span>&amp;&amp;</span> prices<span>[</span>index<span>]</span> <span>&lt;=</span> prices<span>[</span>index <span>+</span> <span>1</span><span>]</span><span>)</span>
            index<span>++</span><span>;</span>
        <span>//计算这段上涨时间的差值，然后累加</span>
        total <span>+=</span> prices<span>[</span>index<span>++</span><span>]</span> <span>-</span> min<span>;</span>
    <span>}</span>
    <span>return</span> total<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div>]]></content:encoded>
      <enclosure url="https://vuepress-theme-hope-demo.mrhope.site/image/104045.png" type="image/png"/>
    </item>
    <item>
      <title>环形链表</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/19.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8.html</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/19.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8.html</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">环形链表</source>
      <pubDate>Mon, 11 Apr 2022 16:35:43 GMT</pubDate>
      <content:encoded><![CDATA[<h3 id="环形链表"> 环形链表</h3>
<h4 id="题目"> 题目：</h4>
<p><img src="/image/215222.png" alt="屏幕截图 2022-04-08 215222" loading="lazy"></p>
<h4 id="解-set-contains判断是否存在"> 解：set.contains判断是否存在</h4>
<div><pre><code><span>public</span> <span>boolean</span> <span>hasCycle</span><span>(</span><span>ListNode</span> head<span>)</span> <span>{</span>
    <span>Set</span><span><span>&lt;</span><span>ListNode</span><span>></span></span> set <span>=</span> <span>new</span> <span>HashSet</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>while</span> <span>(</span>head <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        <span>//如果重复出现说明有环</span>
        <span>if</span> <span>(</span>set<span>.</span><span>contains</span><span>(</span>head<span>)</span><span>)</span>
            <span>return</span> <span>true</span><span>;</span>
        <span>//否则就把当前节点加入到集合中</span>
        set<span>.</span><span>add</span><span>(</span>head<span>)</span><span>;</span>
        head <span>=</span> head<span>.</span>next<span>;</span>
    <span>}</span>
    <span>return</span> <span>false</span><span>;</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div>]]></content:encoded>
      <enclosure url="https://vuepress-theme-hope-demo.mrhope.site/image/215222.png" type="image/png"/>
    </item>
    <item>
      <title>旋转数组</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/3.%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%EF%BC%88%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%EF%BC%89.html</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/3.%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%EF%BC%88%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%EF%BC%89.html</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">旋转数组</source>
      <pubDate>Mon, 11 Apr 2022 16:35:43 GMT</pubDate>
      <content:encoded><![CDATA[<h3 id="旋转数组"> 旋转数组</h3>
<h4 id="题目"> 题目：</h4>
<p><img src="/image/234028.png" alt="屏幕截图 2022-02-24 234028" loading="lazy">****</p>
<h4 id="解-i-k-length"> 解：(i + k) % length</h4>
<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>
    <span>public</span> <span>void</span> <span>rotate</span><span>(</span><span>int</span> nums<span>[</span><span>]</span><span>,</span> <span>int</span> k<span>)</span> <span>{</span>
        <span>int</span> length <span>=</span> nums<span>.</span>length<span>;</span>
        <span>int</span> temp<span>[</span><span>]</span> <span>=</span> <span>new</span> <span>int</span><span>[</span>length<span>]</span><span>;</span>
        <span>//把原数组值放到一个临时数组中，</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            temp<span>[</span>i<span>]</span> <span>=</span> nums<span>[</span>i<span>]</span><span>;</span>
        <span>}</span>
        <span>//然后在把临时数组的值重新放到原数组，并且往右移动k位</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            nums<span>[</span><span>(</span>i <span>+</span> k<span>)</span> <span>%</span> length<span>]</span> <span>=</span> temp<span>[</span>i<span>]</span><span>;</span>
        <span>}</span>
    <span>}</span><span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p><strong>Arrays.copyOfRange</strong>(T[] original, int from, int to) 方法复制指定的数组到一个新的数组。
参数说明：
其中T[] original是要复制的数组，from是复制开始位置的元素的序号（包括这个元素），to复制结束位置的序号（不包括这个元素）。
使用时可能参数错误导致的异常：</p>
<p>ArrayIndexOutOfBoundsException – 如果 from &lt; 0 或 from &gt; original.length()</p>
<p>IllegalArgumentException – 如果 from &gt; to.</p>
<p>NullPointerException – 如果 original 为 null</p>
]]></content:encoded>
      <enclosure url="https://vuepress-theme-hope-demo.mrhope.site/image/234028.png" type="image/png"/>
    </item>
    <item>
      <title>存在重复元素</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/4.Arrays.sort(nums)%EF%BC%9Bset%E9%9B%86%E5%90%88%E6%97%A0%E9%87%8D%E5%A4%8D.html</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/4.Arrays.sort(nums)%EF%BC%9Bset%E9%9B%86%E5%90%88%E6%97%A0%E9%87%8D%E5%A4%8D.html</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">存在重复元素</source>
      <pubDate>Mon, 11 Apr 2022 16:35:43 GMT</pubDate>
      <content:encoded><![CDATA[<h3 id="存在重复元素"> 存在重复元素</h3>
<h4 id="题目"> 题目：</h4>
<p>![屏幕截图 2022-02-25 154340](E:\AA 课件笔记源码资料\1.AAAAAAAAAAAAAAA基础理论\数据结构与算法\image\屏幕截图 2022-02-25 154340.png)</p>
<h4 id="解-arrays-sort-nums-set集合"> 解：Arrays.sort(nums)；set集合</h4>
<div><pre><code>    <span>public</span> <span>boolean</span> <span>containsDuplicate</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
        <span>Set</span><span><span>&lt;</span><span>Integer</span><span>></span></span> set <span>=</span> <span>new</span> <span>HashSet</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> num <span>:</span> nums<span>)</span> <span>{</span>
            <span>//因为集合set中不能有重复的元素，如果有重复的</span>
            <span>//元素添加，就会添加失败</span>
            <span>if</span> <span>(</span><span>!</span>set<span>.</span><span>add</span><span>(</span>num<span>)</span><span>)</span>
                <span>return</span> <span>true</span><span>;</span>
        <span>}</span>
        <span>return</span> <span>false</span><span>;</span>
    <span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code>    <span>public</span> <span>boolean</span> <span>containsDuplicate</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
        <span>Set</span><span><span>&lt;</span><span>Integer</span><span>></span></span> set <span>=</span> <span>new</span> <span>HashSet</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> num <span>:</span> nums<span>)</span> <span>{</span>
            <span>//因为集合set中不能有重复的元素，如果有重复的</span>
            <span>//元素添加，就会添加失败</span>
            <span>if</span> <span>(</span><span>!</span>set<span>.</span><span>add</span><span>(</span>num<span>)</span><span>)</span>
                <span>return</span> <span>true</span><span>;</span>
        <span>}</span>
        <span>return</span> <span>false</span><span>;</span>
    <span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>移动零</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/8.%E5%8F%8C%E6%8C%87%E9%92%88.html</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/8.%E5%8F%8C%E6%8C%87%E9%92%88.html</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">移动零</source>
      <pubDate>Mon, 11 Apr 2022 16:35:43 GMT</pubDate>
      <content:encoded><![CDATA[<h3 id="移动零"> 移动零</h3>
<h4 id="题目"> 题目：</h4>
<p>![屏幕截图 2022-03-03 163747](E:\AA 课件笔记源码资料\1.AAAAAAAAAAAAAAA基础理论\数据结构与算法\image\屏幕截图 2022-03-03 163747.png)</p>
<h4 id="解-nums-index-nums-i"> 解：nums[index++] = nums[i];</h4>
<div><pre><code>    <span>public</span> <span>void</span> <span>moveZeroes</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>nums <span>==</span> <span>null</span> <span>||</span> nums<span>.</span>length <span>==</span> <span>0</span><span>)</span>
            <span>return</span><span>;</span>
        <span>int</span> index <span>=</span> <span>0</span><span>;</span>
        <span>//一次遍历，把非零的都往前挪</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> nums<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>nums<span>[</span>i<span>]</span> <span>!=</span> <span>0</span><span>)</span>
                nums<span>[</span>index<span>++</span><span>]</span> <span>=</span> nums<span>[</span>i<span>]</span><span>;</span>
        <span>}</span>
        <span>//后面的都是0,</span>
        <span>while</span> <span>(</span>index <span>&lt;</span> nums<span>.</span>length<span>)</span> <span>{</span>
            nums<span>[</span>index<span>++</span><span>]</span> <span>=</span> <span>0</span><span>;</span>
        <span>}</span>
    <span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>只出现一次的数字</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/5.%E4%BD%8D%E8%BF%90%E7%AE%97%EF%BC%9B%E9%9B%86%E5%90%88set.html</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/5.%E4%BD%8D%E8%BF%90%E7%AE%97%EF%BC%9B%E9%9B%86%E5%90%88set.html</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">只出现一次的数字</source>
      <pubDate>Mon, 11 Apr 2022 16:35:43 GMT</pubDate>
      <content:encoded><![CDATA[<h3 id="只出现一次的数字"> 只出现一次的数字</h3>
<h4 id="题目"> 题目：</h4>
<p>![屏幕截图 2022-02-26 153910](E:\AA 课件笔记源码资料\1.AAAAAAAAAAAAAAA基础理论\数据结构与算法\image\屏幕截图 2022-02-26 153910.png)</p>
<h4 id="解-位运算解决-使用集合set解决"> 解：位运算解决；使用集合Set解决</h4>
<div><pre><code><span>public</span> <span>int</span> <span>singleNumber</span><span>(</span><span>int</span> nums<span>[</span><span>]</span><span>)</span> <span>{</span>
    <span>int</span> result <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> nums<span>.</span>length<span>;</span> i<span>++</span><span>)</span>
        result <span>^=</span> nums<span>[</span>i<span>]</span><span>;</span>
    <span>return</span> result<span>;</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><div><pre><code><span>public</span> <span>int</span> <span>singleNumber</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
    <span>Set</span><span><span>&lt;</span><span>Integer</span><span>></span></span> set <span>=</span> <span>new</span> <span>HashSet</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> num <span>:</span> nums<span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>!</span>set<span>.</span><span>add</span><span>(</span>num<span>)</span><span>)</span> <span>{</span>
            <span>//如果添加失败，说明这个值</span>
            <span>//在集合Set中存在，我们要</span>
            <span>//把他给移除掉</span>
            set<span>.</span><span>remove</span><span>(</span>num<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>//最终集合Set中只有一个元素，我们直接返回</span>
    <span>return</span> <span>(</span><span>int</span><span>)</span> set<span>.</span><span>toArray</span><span>(</span><span>)</span><span>[</span><span>0</span><span>]</span><span>;</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>加一</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/7.%E6%95%B4%E6%95%B0%E5%8A%A0%E4%B8%80.html</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/7.%E6%95%B4%E6%95%B0%E5%8A%A0%E4%B8%80.html</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">加一</source>
      <pubDate>Mon, 11 Apr 2022 16:35:43 GMT</pubDate>
      <content:encoded><![CDATA[<h3 id="加一"> 加一</h3>
<h4 id="题目"> 题目：</h4>
<p>![屏幕截图 2022-02-28 100926](E:\AA 课件笔记源码资料\1.AAAAAAAAAAAAAAA基础理论\数据结构与算法\image\屏幕截图 2022-02-28 100926.png)</p>
<h4 id="解"> 解：</h4>
<div><pre><code>    <span>public</span> <span>int</span><span>[</span><span>]</span> <span>plusOne</span><span>(</span><span>int</span><span>[</span><span>]</span> digits<span>)</span> <span>{</span>
        <span>int</span> length <span>=</span> digits<span>.</span>length<span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> length <span>-</span> <span>1</span><span>;</span> i <span>>=</span> <span>0</span><span>;</span> i<span>--</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>digits<span>[</span>i<span>]</span> <span>!=</span> <span>9</span><span>)</span> <span>{</span>
                <span>//如果数组当前元素不等于9，直接加1</span>
                <span>//然后直接返回</span>
                digits<span>[</span>i<span>]</span><span>++</span><span>;</span>
                <span>return</span> digits<span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                <span>//如果数组当前元素等于9，那么加1之后</span>
                <span>//肯定会变为0，我们先让他变为0</span>
                digits<span>[</span>i<span>]</span> <span>=</span> <span>0</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>//除非数组中的元素都是9，否则不会走到这一步，</span>
        <span>//如果数组的元素都是9，我们只需要把数组的长度</span>
        <span>//增加1，并且把数组的第一个元素置为1即可</span>
        <span>int</span> temp<span>[</span><span>]</span> <span>=</span> <span>new</span> <span>int</span><span>[</span>length <span>+</span> <span>1</span><span>]</span><span>;</span>
        temp<span>[</span><span>0</span><span>]</span> <span>=</span> <span>1</span><span>;</span>
        <span>return</span> temp<span>;</span>
    <span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>两个数组的交集 II</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/6.%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%9Bmap.getOrDefault.html</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/6.%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%9Bmap.getOrDefault.html</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">两个数组的交集 II</source>
      <pubDate>Mon, 11 Apr 2022 16:35:43 GMT</pubDate>
      <content:encoded><![CDATA[<h3 id="两个数组的交集-ii"> 两个数组的交集 II</h3>
<h4 id="题目"> 题目：</h4>
<p>![屏幕截图 2022-02-27 104536](E:\AA 课件笔记源码资料\1.AAAAAAAAAAAAAAA基础理论\数据结构与算法\image\屏幕截图 2022-02-27 104536.png)</p>
<h4 id="解-双指针-map"> 解：双指针；map</h4>
<div><pre><code>    <span>public</span> <span>int</span><span>[</span><span>]</span> <span>intersect</span><span>(</span><span>int</span><span>[</span><span>]</span> nums1<span>,</span> <span>int</span><span>[</span><span>]</span> nums2<span>)</span> <span>{</span>
        <span>// 先对两个数组进行排序</span>
        <span>Arrays</span><span>.</span><span>sort</span><span>(</span>nums1<span>)</span><span>;</span>
        <span>Arrays</span><span>.</span><span>sort</span><span>(</span>nums2<span>)</span><span>;</span>
        <span>int</span> i <span>=</span> <span>0</span><span>;</span>
        <span>int</span> j <span>=</span> <span>0</span><span>;</span>
        <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>while</span> <span>(</span>i <span>&lt;</span> nums1<span>.</span>length <span>&amp;&amp;</span> j <span>&lt;</span> nums2<span>.</span>length<span>)</span> <span>{</span>
            <span>if</span> <span>(</span>nums1<span>[</span>i<span>]</span> <span>&lt;</span> nums2<span>[</span>j<span>]</span><span>)</span> <span>{</span>
                <span>// 如果i指向的值小于j指向的值，，说明i指向</span>
                <span>// 的值小了，i往后移一步</span>
                i<span>++</span><span>;</span>
            <span>}</span> <span>else</span> <span>if</span> <span>(</span>nums1<span>[</span>i<span>]</span> <span>></span> nums2<span>[</span>j<span>]</span><span>)</span> <span>{</span>
                <span>// 如果i指向的值大于j指向的值，说明j指向的值</span>
                <span>// 小了，j往后移一步</span>
                j<span>++</span><span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                <span>// 如果i和j指向的值相同，说明这两个值是重复的，</span>
                <span>// 把他加入到集合list中，然后i和j同时都往后移一步</span>
                list<span>.</span><span>add</span><span>(</span>nums1<span>[</span>i<span>]</span><span>)</span><span>;</span>
                i<span>++</span><span>;</span>
                j<span>++</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>//把list转化为数组</span>
        <span>int</span> index <span>=</span> <span>0</span><span>;</span>
        <span>int</span><span>[</span><span>]</span> res <span>=</span> <span>new</span> <span>int</span><span>[</span>list<span>.</span><span>size</span><span>(</span><span>)</span><span>]</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> k <span>=</span> <span>0</span><span>;</span> k <span>&lt;</span> list<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span> k<span>++</span><span>)</span> <span>{</span>
            res<span>[</span>index<span>++</span><span>]</span> <span>=</span> list<span>.</span><span>get</span><span>(</span>k<span>)</span><span>;</span>
        <span>}</span>
        <span>return</span> res<span>;</span>
    <span>}</span>


使用map来解决，具体操作如下

遍历nums1中的所有元素，把它存放到map中，其中key就是nums1中的元素，value就是这个元素在数组nums1中出现的次数。

遍历nums2中的所有元素，查看map中是否包含nums2的元素，如果包含，就把当前值加入到集合list中，然后对应的value要减<span>1</span>。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div><div><pre><code>    <span>public</span> <span>int</span><span>[</span><span>]</span> <span>intersect</span><span>(</span><span>int</span><span>[</span><span>]</span> nums1<span>,</span> <span>int</span><span>[</span><span>]</span> nums2<span>)</span> <span>{</span>
        <span>HashMap</span><span><span>&lt;</span><span>Integer</span><span>,</span> <span>Integer</span><span>></span></span> map <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>ArrayList</span><span><span>&lt;</span><span>Integer</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>

        <span>//先把数组nums1的所有元素都存放到map中，其中key是数组中</span>
        <span>//的元素，value是这个元素出现在数组中的次数</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> nums1<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            map<span>.</span><span>put</span><span>(</span>nums1<span>[</span>i<span>]</span><span>,</span> map<span>.</span><span>getOrDefault</span><span>(</span>nums1<span>[</span>i<span>]</span><span>,</span> <span>0</span><span>)</span> <span>+</span> <span>1</span><span>)</span><span>;</span>
        <span>}</span>

        <span>//然后再遍历nums2数组，查看map中是否包含nums2的元素，如果包含，</span>
        <span>//就把当前值加入到集合list中，然后再把对应的value值减1。</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> nums2<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>map<span>.</span><span>getOrDefault</span><span>(</span>nums2<span>[</span>i<span>]</span><span>,</span> <span>0</span><span>)</span> <span>></span> <span>0</span><span>)</span> <span>{</span>
                list<span>.</span><span>add</span><span>(</span>nums2<span>[</span>i<span>]</span><span>)</span><span>;</span>
                map<span>.</span><span>put</span><span>(</span>nums2<span>[</span>i<span>]</span><span>,</span> map<span>.</span><span>get</span><span>(</span>nums2<span>[</span>i<span>]</span><span>)</span> <span>-</span> <span>1</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>

        <span>//把集合list转化为数组</span>
        <span>int</span><span>[</span><span>]</span> res <span>=</span> <span>new</span> <span>int</span><span>[</span>list<span>.</span><span>size</span><span>(</span><span>)</span><span>]</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> list<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
            res<span>[</span>i<span>]</span> <span>=</span> list<span>.</span><span>get</span><span>(</span>i<span>)</span><span>;</span>
        <span>}</span>
        <span>return</span> res<span>;</span>
    <span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>Java 常见对象</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/Java%20%E5%B8%B8%E8%A7%81%E5%AF%B9%E8%B1%A1.html</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/Java%20%E5%B8%B8%E8%A7%81%E5%AF%B9%E8%B1%A1.html</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">Java 常见对象</source>
      <pubDate>Mon, 11 Apr 2022 16:35:43 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="java-常见对象"> Java 常见对象</h2>
<h3 id="object"> Object</h3>
<h4 id="object-类的常见方法有哪些"> Object 类的常见方法有哪些？</h4>
<p>Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法：</p>
<div><pre><code><span>/**
 * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。
 */</span>
<span>public</span> <span>final</span> <span>native</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> <span>getClass</span><span>(</span><span>)</span>
<span>/**
 * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。
 */</span>
<span>public</span> <span>native</span> <span>int</span> <span>hashCode</span><span>(</span><span>)</span>
<span>/**
 * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。
 */</span>
<span>public</span> <span>boolean</span> <span>equals</span><span>(</span><span>Object</span> obj<span>)</span>
<span>/**
 * naitive 方法，用于创建并返回当前对象的一份拷贝。
 */</span>
<span>protected</span> <span>native</span> <span>Object</span> <span>clone</span><span>(</span><span>)</span> <span>throws</span> <span>CloneNotSupportedException</span>
<span>/**
 * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。
 */</span>
<span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span>
<span>/**
 * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。
 */</span>
<span>public</span> <span>final</span> <span>native</span> <span>void</span> <span>notify</span><span>(</span><span>)</span>
<span>/**
 * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。
 */</span>
<span>public</span> <span>final</span> <span>native</span> <span>void</span> <span>notifyAll</span><span>(</span><span>)</span>
<span>/**
 * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。
 */</span>
<span>public</span> <span>final</span> <span>native</span> <span>void</span> <span>wait</span><span>(</span><span>long</span> timeout<span>)</span> <span>throws</span> <span>InterruptedException</span>
<span>/**
 * 多了 nanos 参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 毫秒。。
 */</span>
<span>public</span> <span>final</span> <span>void</span> <span>wait</span><span>(</span><span>long</span> timeout<span>,</span> <span>int</span> nanos<span>)</span> <span>throws</span> <span>InterruptedException</span>
<span>/**
 * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念
 */</span>
<span>public</span> <span>final</span> <span>void</span> <span>wait</span><span>(</span><span>)</span> <span>throws</span> <span>InterruptedException</span>
<span>/**
 * 实例被垃圾回收器回收的时候触发的操作
 */</span>
<span>protected</span> <span>void</span> <span>finalize</span><span>(</span><span>)</span> <span>throws</span> <span>Throwable</span> <span>{</span> <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div><h4 id="和-equals-的区别"> == 和 equals() 的区别</h4>
<p><strong><code>==</code></strong> 对于基本类型和引用类型的作用效果是不同的：</p>
<ul>
<li>对于基本数据类型来说，<code>==</code> 比较的是值。</li>
<li>对于引用数据类型来说，<code>==</code> 比较的是对象的内存地址。</li>
</ul>
<blockquote>
<p>因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p>
</blockquote>
<p><strong><code>equals()</code></strong> 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类，因此所有的类都有<code>equals()</code>方法。</p>
<p><code>equals()</code> 方法存在两种使用情况：</p>
<ul>
<li><strong>类没有重写 <code>equals()</code>方法</strong> ：通过<code>equals()</code>比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 <code>Object</code>类<code>equals()</code>方法。</li>
<li><strong>类重写了 <code>equals()</code>方法</strong> ：一般我们都重写 <code>equals()</code>方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。</li>
</ul>
<p><code>String</code> 中的 <code>equals</code> 方法是被重写过的，因为 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址，而 <code>String</code> 的 <code>equals</code> 方法比较的是对象的值。</p>
<p>当创建 <code>String</code> 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 <code>String</code> 对象。</p>
<h4 id="hashcode-有什么用"> hashCode() 有什么用？</h4>
<p><code>hashCode()</code> 的作用是获取哈希码（<code>int</code> 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。</p>
<p><code>hashCode()</code>定义在 JDK 的 <code>Object</code> 类中，这就意味着 Java 中的任何类都包含有 <code>hashCode()</code> 函数。另外需要注意的是： <code>Object</code> 的 <code>hashCode()</code> 方法是本地方法，也就是用 C 语言或 C++ 实现的，该方法通常用来将对象的内存地址转换为整数之后返回。</p>
<p>散列表存储的是键值对(key-value)，它的特点是：<strong>能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</strong></p>
<h4 id="为什么要有-hashcode"> 为什么要有 hashCode？</h4>
<blockquote>
<p>当你把对象加入 <code>HashSet</code> 时，<code>HashSet</code> 会先计算对象的 <code>hashCode</code> 值来判断对象加入的位置，同时也会与其他已经加入的对象的 <code>hashCode</code> 值作比较，如果没有相符的 <code>hashCode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashCode</code> 值的对象，这时会调用 <code>equals()</code> 方法来检查 <code>hashCode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 <code>equals</code> 的次数，相应就大大提高了执行速度。</p>
</blockquote>
<p>其实， <code>hashCode()</code> 和 <code>equals()</code>都是用于比较两个对象是否相等。</p>
<p><strong>那为什么 JDK 还要同时提供这两个方法呢？</strong></p>
<p>这是因为在一些容器（比如 <code>HashMap</code>、<code>HashSet</code>）中，有了 <code>hashCode()</code> 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进<code>HastSet</code>的过程）！</p>
<p>我们在前面也提到了添加元素进<code>HastSet</code>的过程，如果 <code>HashSet</code> 在对比的时候，同样的 <code>hashCode</code> 有多个对象，它会继续使用 <code>equals()</code> 来判断是否真的相同。也就是说 <code>hashCode</code> 帮助我们大大缩小了查找成本。</p>
<p><strong>那为什么不只提供 <code>hashCode()</code> 方法呢？</strong></p>
<p>这是因为两个对象的<code>hashCode</code> 值相等并不代表两个对象就相等。</p>
<p><strong>那为什么两个对象有相同的 <code>hashCode</code> 值，它们也不一定是相等的？</strong></p>
<p>因为 <code>hashCode()</code> 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓哈希碰撞也就是指的是不同的对象得到相同的 <code>hashCode</code> )。</p>
<p>总结下来就是 ：</p>
<ul>
<li>如果两个对象的<code>hashCode</code> 值相等，那这两个对象不一定相等（哈希碰撞）。</li>
<li>如果两个对象的<code>hashCode</code> 值相等并且<code>equals()</code>方法也返回 <code>true</code>，我们才认为这两个对象相等。</li>
<li>如果两个对象的<code>hashCode</code> 值不相等，我们就可以直接认为这两个对象不相等。</li>
</ul>
<h4 id="为什么重写-equals-时必须重写-hashcode-方法"> 为什么重写 equals() 时必须重写 hashCode() 方法？</h4>
<p>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p>
<p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p>
<p><strong>总结</strong> ：</p>
<ul>
<li><code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</li>
<li>两个对象有相同的 <code>hashCode</code> 值，他们也不一定是相等的（哈希碰撞）。</li>
</ul>
<h3 id="string"> String</h3>
<h4 id="string、stringbuffer、stringbuilder-的区别"> String、StringBuffer、StringBuilder 的区别？</h4>
<p><strong>可变性</strong></p>
<p><code>String</code> 是不可变的（后面会详细分析原因）。</p>
<p><code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，最关键的是这个 <code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法比如 <code>append</code> 方法。</p>
<p><strong>线程安全性</strong></p>
<p><code>String</code> 中的对象是不可变的，也就可以理解为常量，线程安全。<code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。<code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。<code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的。</p>
<p><strong>性能</strong></p>
<p>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
<p><strong>对于三者使用的总结：</strong></p>
<ol>
<li>操作少量的数据: 适用 <code>String</code></li>
<li>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li>
<li>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li>
</ol>
<h4 id="string-为什么是不可变的"> String 为什么是不可变的?</h4>
<blockquote>
<p>我们知道被 <code>final</code> 关键字修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象。因此，<code>final</code> 关键字修饰的数组保存字符串并不是 <code>String</code> 不可变的根本原因，因为这个数组保存的字符串是可变的（<code>final</code> 修饰引用类型变量的情况）。</p>
<p><code>String</code> 真正不可变有下面几点原因：</p>
<ol>
<li>保存字符串的数组被 <code>final</code> 修饰且为私有的，并且<code>String</code> 类没有提供/暴露修改这个字符串的方法。</li>
<li><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</li>
</ol>
</blockquote>
<p><strong>Java 9 为何要将 <code>String</code> 的底层实现由 <code>char[]</code> 改成了 <code>byte[]</code> ?</strong></p>
<p>新版的 String 其实支持两个编码方案： Latin-1 和 UTF-16。如果字符串中包含的汉字没有超过 Latin-1 可表示范围内的字符，那就会使用 Latin-1 作为编码方案。Latin-1 编码方案下，<code>byte</code> 占一个字节(8 位)，<code>char</code> 占用 2 个字节（16），<code>byte</code> 相较 <code>char</code> 节省一半的内存空间。</p>
<p>JDK 官方就说了绝大部分字符串对象只包含 Latin-1 可表示的字符。</p>
<p>如果字符串中包含的汉字超过 Latin-1 可表示范围内的字符，<code>byte</code> 和 <code>char</code> 所占用的空间是一样的。</p>
<h4 id="字符串拼接用-还是-stringbuilder"> 字符串拼接用“+” 还是 StringBuilder?</h4>
<p>Java 语言本身并不支持运算符重载，“+”和“+=”是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的元素符。</p>
<div><pre><code><span>String</span> str1 <span>=</span> <span>"he"</span><span>;</span>
<span>String</span> str2 <span>=</span> <span>"llo"</span><span>;</span>
<span>String</span> str3 <span>=</span> <span>"world"</span><span>;</span>
<span>String</span> str4 <span>=</span> str1 <span>+</span> str2 <span>+</span> str3<span>;</span><span>Copy</span> <span>to</span> <span>clipboardErrorCopied</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>对象引用和“+”的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/touzi/image-20220131173604062.png" alt="img" loading="lazy"></p>
<p>不过，在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：<strong>编译器不会创建单个 <code>StringBuilder</code> 以复用，会导致创建过多的 <code>StringBuilder</code> 对象</strong>。</p>
<div><pre><code><span>String</span><span>[</span><span>]</span> arr <span>=</span> <span>{</span><span>"he"</span><span>,</span> <span>"llo"</span><span>,</span> <span>"world"</span><span>}</span><span>;</span>
<span>String</span> s <span>=</span> <span>""</span><span>;</span>
<span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    s <span>+=</span> arr<span>[</span>i<span>]</span><span>;</span>
<span>}</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s<span>)</span><span>;</span><span>Copy</span> <span>to</span> <span>clipboardErrorCopied</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><code>StringBuilder</code> 对象是在循环内部被创建的，这意味着每循环一次就会创建一个 <code>StringBuilder</code> 对象。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/touzi/image-20220131175013108.png" alt="img" loading="lazy"></p>
<p>如果直接使用 <code>StringBuilder</code> 对象进行字符串拼接的话，就不会存在这个问题了。</p>
<h4 id="string-equals-和-object-equals-有何区别"> String#equals() 和 Object#equals() 有何区别？</h4>
<p><code>String</code> 中的 <code>equals</code> 方法是被重写过的，比较的是 String 字符串的值是否相等。 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址。</p>
<h4 id="字符串常量池的作用了解吗"> 字符串常量池的作用了解吗？</h4>
<p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p>
<div><pre><code><span>String</span> aa <span>=</span> <span>"ab"</span><span>;</span> <span>// 放在常量池中</span>
<span>String</span> bb <span>=</span> <span>"ab"</span><span>;</span> <span>// 从常量池中查找</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>aa<span>==</span>bb<span>)</span><span>;</span><span>// trueCopy to clipboardErrorCopied</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区。JDK1.7 的时候，字符串常量池被从方法区拿到了堆中。</p>
<h4 id="string-s1-new-string-abc-这句话创建了几个字符串对象"> String s1 = new String(&quot;abc&quot;);这句话创建了几个字符串对象？</h4>
<p>会创建 1 或 2 个字符串：</p>
<ul>
<li>如果字符串常量池中已存在字符串常量“abc”，则只会在堆空间创建一个字符串常量“abc”。</li>
<li>如果字符串常量池中没有字符串常量“abc”，那么它将首先在字符串常量池中创建，然后在堆空间中创建，因此将创建总共 2 个字符串对象。</li>
</ul>
<p><strong>验证</strong> ：</p>
<div><pre><code><span>String</span> s1 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>"abc"</span><span>)</span><span>;</span><span>// 堆内存的地址值</span>
<span>String</span> s2 <span>=</span> <span>"abc"</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s1 <span>==</span> s2<span>)</span><span>;</span><span>// 输出 false,因为一个是堆内存，一个是常量池的内存，故两者是不同的。</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s1<span>.</span><span>equals</span><span>(</span>s2<span>)</span><span>)</span><span>;</span><span>// 输出 trueCopy to clipboardErrorCopied</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>结果</strong> ：</p>
<div><pre><code><span>false</span>
<span>true</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h4 id="string-类型的变量和常量做-运算时发生了什么"> String 类型的变量和常量做“+”运算时发生了什么？</h4>
<div><pre><code><span>String</span> str1 <span>=</span> <span>"str"</span><span>;</span>
<span>String</span> str2 <span>=</span> <span>"ing"</span><span>;</span>
<span>String</span> str3 <span>=</span> <span>"str"</span> <span>+</span> <span>"ing"</span><span>;</span><span>//常量池中的对象</span>
<span>String</span> str4 <span>=</span> str1 <span>+</span> str2<span>;</span> <span>//在堆上创建的新的对象</span>
<span>String</span> str5 <span>=</span> <span>"string"</span><span>;</span><span>//常量池中的对象</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str3 <span>==</span> str4<span>)</span><span>;</span><span>//false</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str3 <span>==</span> str5<span>)</span><span>;</span><span>//true</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str4 <span>==</span> str5<span>)</span><span>;</span><span>//false</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。</p>
<blockquote>
<p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p>
<div><pre><code><span>String</span> aa <span>=</span> <span>"ab"</span><span>;</span> <span>// 放在常量池中</span>
<span>String</span> bb <span>=</span> <span>"ab"</span><span>;</span> <span>// 从常量池中查找</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>aa<span>==</span>bb<span>)</span><span>;</span><span>// trueCopy to clipboardErrorCopied</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区。JDK1.7 的时候，字符串常量池被从方法区拿到了堆中。</p>
</blockquote>
<p>并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。</p>
<blockquote>
<p>在编译过程中，Javac 编译器（下文中统称为编译器）会进行一个叫做 <strong>常量折叠(Constant Folding)</strong> 的代码优化。《深入理解 Java 虚拟机》中是也有介绍到：</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/image-20210817142715396.png" alt="img" loading="lazy"></p>
<p>常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。</p>
<p>对于 <code>String str3 = &quot;str&quot; + &quot;ing&quot;;</code> 编译器会给你优化成 <code>String str3 = &quot;string&quot;;</code> 。</p>
<p>并不是所有的常量都会进行折叠，只有编译器在程序编译期就可以确定值的常量才可以：</p>
<ul>
<li>基本数据类型( <code>byte</code>、<code>boolean</code>、<code>short</code>、<code>char</code>、<code>int</code>、<code>float</code>、<code>long</code>、<code>double</code>)以及字符串常量。</li>
<li><code>final</code> 修饰的基本数据类型和字符串变量</li>
<li>字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（&lt;&lt;、&gt;&gt;、&gt;&gt;&gt; ）</li>
</ul>
</blockquote>
<p>因此，<code>str1</code> 、 <code>str2</code> 、 <code>str3</code> 都属于字符串常量池中的对象。</p>
<p>引用的值在程序编译期是无法确定的，编译器无法对其进行优化。</p>
<p>对象引用和“+”的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</p>
<div><pre><code><span>String</span> str4 <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>)</span><span>.</span><span>append</span><span>(</span>str1<span>)</span><span>.</span><span>append</span><span>(</span>str2<span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span><span>Copy</span> <span>to</span> <span>clipboardErrorCopied</span>
</code></pre>
<div><span>1</span><br></div></div><p>因此，<code>str4</code> 并不是字符串常量池中存在的对象，属于堆上的新对象。</p>
<p>我画了一个图帮助理解：</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/字符串拼接-常量池.png" alt="img" loading="lazy"></p>
<p>我们在平时写代码的时候，尽量避免多个字符串对象拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 <code>StringBuilder</code> 或者 <code>StringBuffer</code>。</p>
<p>不过，字符串使用 <code>final</code> 关键字声明之后，可以让编译器当做常量来处理。</p>
<div><pre><code><span>final</span> <span>String</span> str1 <span>=</span> <span>"str"</span><span>;</span>
<span>final</span> <span>String</span> str2 <span>=</span> <span>"ing"</span><span>;</span>
<span>// 下面两个表达式其实是等价的</span>
<span>String</span> c <span>=</span> <span>"str"</span> <span>+</span> <span>"ing"</span><span>;</span><span>// 常量池中的对象</span>
<span>String</span> d <span>=</span> str1 <span>+</span> str2<span>;</span> <span>// 常量池中的对象</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>c <span>==</span> d<span>)</span><span>;</span><span>// trueCopy to clipboardErrorCopied</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>被 <code>final</code> 关键字修改之后的 <code>String</code> 会被编译器当做常量来处理，编译器在程序编译期就可以确定它的值，其效果就相当于访问常量。</p>
<p>如果 ，编译器在运行时才能知道其确切值的话，就无法对其优化。</p>
<div><pre><code><span>final</span> <span>String</span> str1 <span>=</span> <span>"str"</span><span>;</span>
<span>final</span> <span>String</span> str2 <span>=</span> <span>getStr</span><span>(</span><span>)</span><span>;</span>
<span>String</span> c <span>=</span> <span>"str"</span> <span>+</span> <span>"ing"</span><span>;</span><span>// 常量池中的对象</span>
<span>String</span> d <span>=</span> str1 <span>+</span> str2<span>;</span> <span>// 在堆上创建的新的对象</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>c <span>==</span> d<span>)</span><span>;</span><span>// false</span>
<span>public</span> <span>static</span> <span>String</span> <span>getStr</span><span>(</span><span>)</span> <span>{</span>
      <span>return</span> <span>"ing"</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><strong>我们再来看一个类似的问题！</strong></p>
<div><pre><code><span>String</span> str1 <span>=</span> <span>"abcd"</span><span>;</span>
<span>String</span> str2 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>"abcd"</span><span>)</span><span>;</span>
<span>String</span> str3 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>"abcd"</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str1<span>==</span>str2<span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str2<span>==</span>str3<span>)</span><span>;</span><span>Copy</span> <span>to</span> <span>clipboardErrorCopied</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>上面的代码运行之后会输出什么呢？</p>
<p>答案是：</p>
<div><pre><code>false
falseCopy to clipboardErrorCopied
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>这是为什么呢？</strong></p>
<p>我们先来看下面这种创建字符串对象的方式：</p>
<div><pre><code><span>// 从字符串常量池中拿对象</span>
<span>String</span> str1 <span>=</span> <span>"abcd"</span><span>;</span><span>Copy</span> <span>to</span> <span>clipboardErrorCopied</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>这种情况下，jvm 会先检查字符串常量池中有没有&quot;abcd&quot;，如果字符串常量池中没有，则创建一个，然后 str1 指向字符串常量池中的对象，如果有，则直接将 str1 指向&quot;abcd&quot;；</p>
<p>因此，<code>str1</code> 指向的是字符串常量池的对象。</p>
<p>我们再来看下面这种创建字符串对象的方式：</p>
<div><pre><code><span>// 直接在堆内存空间创建一个新的对象。</span>
<span>String</span> str2 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>"abcd"</span><span>)</span><span>;</span>
<span>String</span> str3 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>"abcd"</span><span>)</span><span>;</span><span>Copy</span> <span>to</span> <span>clipboardErrorCopied</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>只要使用 new 的方式创建对象，便需要创建新的对象</strong> 。</p>
<p>使用 new 的方式创建对象的方式如下，可以简单概括为 3 步：</p>
<ol>
<li>在堆中创建一个字符串对象</li>
<li>检查字符串常量池中是否有和 new 的字符串值相等的字符串常量</li>
<li>如果没有的话需要在字符串常量池中也创建一个值相等的字符串常量，如果有的话，就直接返回堆中的字符串实例对象地址。</li>
</ol>
<p>因此，<code>str2</code> 和 <code>str3</code> 都是在堆中新创建的对象。</p>
<p><strong>字符串常量池比较特殊，它的主要使用方法有两种：</strong></p>
<ol>
<li>直接使用双引号声明出来的 <code>String</code> 对象会直接存储在常量池中。</li>
<li>如果不是用双引号声明的 <code>String</code> 对象，使用 <code>String</code> 提供的 <code>intern()</code> 方法也有同样的效果。<code>String.intern()</code> 是一个 Native 方法，它的作用是：如果字符串常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用；如果没有，JDK1.7 之前（不包含 1.7）的处理方式是在常量池中创建与此 <code>String</code> 内容相同的字符串，并返回常量池中创建的字符串的引用，JDK1.7 以及之后，字符串常量池被从方法区拿到了堆中，jvm 不会在常量池中创建该对象，而是将堆中这个对象的引用直接放到常量池中，减少不必要的内存开销。</li>
</ol>
<p>示例代码如下（JDK 1.8） :</p>
<div><pre><code><span>String</span> s1 <span>=</span> <span>"Javatpoint"</span><span>;</span>
<span>String</span> s2 <span>=</span> s1<span>.</span><span>intern</span><span>(</span><span>)</span><span>;</span>
<span>String</span> s3 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>"Javatpoint"</span><span>)</span><span>;</span>
<span>String</span> s4 <span>=</span> s3<span>.</span><span>intern</span><span>(</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s1<span>==</span>s2<span>)</span><span>;</span> <span>// True</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s1<span>==</span>s3<span>)</span><span>;</span> <span>// False</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s1<span>==</span>s4<span>)</span><span>;</span> <span>// True</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s2<span>==</span>s3<span>)</span><span>;</span> <span>// False</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s2<span>==</span>s4<span>)</span><span>;</span> <span>// True</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s3<span>==</span>s4<span>)</span><span>;</span> <span>// False</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p><strong>总结</strong> ：</p>
<ol>
<li>对于基本数据类型来说，==比较的是值。对于引用数据类型来说，==比较的是对象的内存地址。</li>
<li>在编译过程中，Javac 编译器（下文中统称为编译器）会进行一个叫做 <strong>常量折叠(Constant Folding)</strong> 的代码优化。常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。</li>
<li>一般来说，我们要尽量避免通过 new 的方式创建字符串。使用双引号声明的 <code>String</code> 对象（ <code>String s1 = &quot;java&quot;</code> ）更利于让编译器有机会优化我们的代码，同时也更易于阅读。</li>
<li>被 <code>final</code> 关键字修改之后的 <code>String</code> 会被编译器当做常量来处理，编译器程序编译期就可以确定它的值，其效果就相当于访问常量。</li>
</ol>
<blockquote>
<i>Not supported content</i></blockquote>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/touzi/image-20220131173604062.png" type="image/png"/>
    </item>
    <item>
      <title>测试</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/test.html</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/test.html</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">测试</source>
      <pubDate>Mon, 11 Apr 2022 16:35:43 GMT</pubDate>
      <content:encoded><![CDATA[<p>##hello##</p>
]]></content:encoded>
    </item>
    <item>
      <title>两数之和</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/9.Hashmap.html</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/9.Hashmap.html</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">两数之和</source>
      <pubDate>Mon, 11 Apr 2022 16:35:43 GMT</pubDate>
      <content:encoded><![CDATA[<h3 id="两数之和"> 两数之和</h3>
<h4 id="题目"> 题目：</h4>
<p>![屏幕截图 2022-03-04 235402](E:\AA 课件笔记源码资料\1.AAAAAAAAAAAAAAA基础理论\数据结构与算法\image\屏幕截图 2022-03-04 235402.png)</p>
<h4 id="解-hashmap"> 解：HashMap</h4>
<div><pre><code>    <span>public</span> <span>int</span><span>[</span><span>]</span> <span>twoSum</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> target<span>)</span> <span>{</span>
        <span>Map</span><span><span>&lt;</span><span>Integer</span><span>,</span> <span>Integer</span><span>></span></span> m <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> nums<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>m<span>.</span><span>get</span><span>(</span>target <span>-</span> nums<span>[</span>i<span>]</span><span>)</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span>
                <span>return</span> <span>new</span> <span>int</span><span>[</span><span>]</span><span>{</span>m<span>.</span><span>get</span><span>(</span>target <span>-</span> nums<span>[</span>i<span>]</span><span>)</span><span>,</span> i<span>}</span><span>;</span>
            <span>}</span>
            m<span>.</span><span>put</span><span>(</span>nums<span>[</span>i<span>]</span><span>,</span> i<span>)</span><span>;</span>
        <span>}</span>
        <span>return</span> <span>new</span> <span>int</span><span>[</span><span>]</span><span>{</span><span>0</span><span>,</span> <span>0</span><span>}</span><span>;</span>
    <span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>基础概念与常识</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/Java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%B8%B8%E8%AF%86.html</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/Java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%B8%B8%E8%AF%86.html</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">基础概念与常识</source>
      <pubDate>Mon, 11 Apr 2022 16:35:43 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="基础概念与常识"> 基础概念与常识</h2>
<h3 id="java-语言有哪些特点"> Java 语言有哪些特点?</h3>
<ol>
<li>面向对象（封装，继承，多态）</li>
<li>跨平台（JVM）</li>
<li>编译与解释并存</li>
<li>可靠性，安全性</li>
</ol>
<h3 id="jdk-jre-jvm"> JDK,JRE,JVM</h3>
<h4 id="jdk"> JDK</h4>
<p>JDK 是 Java Development Kit 缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有<strong>编译器（javac）<strong>和</strong>工具（如 javadoc 和 jdb）</strong>。它能够创建和编译程序。</p>
<h4 id="jre"> JRE</h4>
<p>JRE 是 <strong>Java 运行时环境</strong>。它是运行已编译 Java 程序所需的所有内容的集合，包括 <strong>Java 虚拟机（JVM）</strong>，<strong>Java 类库，java 命令和其他的一些基础构件</strong>。但是，它不能用于创建新程序。</p>
<h4 id="jvm"> JVM</h4>
<p>Java虚拟机（JVM）是运行<strong>Java字节码文件</strong>的虚拟机，JVM有针对不同系统特定实现，（跨平台）</p>
<p>JVM 并不是只有一种！只要满足 JVM 规范，每个公司、组织或者个人都可以开发自己的专属 JVM。</p>
<h3 id="什么是字节码-采用字节码的好处是什么"> 什么是字节码?采用字节码的好处是什么?</h3>
<p>​	在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 <strong><code>.class</code> 的文件</strong>），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在<strong>一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点</strong>。所以， Java 程序运行时相对来说还是高效的（不过，和 C++，Rust，Go 等语言还是有一定差距的），而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p>
<p><img src="https://snailclimb.gitee.io/javaguide/docs/java/basis/images/java程序转变为机器代码的过程.png" alt="Java程序转变为机器代码的过程" loading="lazy"></p>
<p>我们需要格外注意的是 <code>.class-&gt;机器码</code> 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT（just-in-time compilation） 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 <strong>Java 是编译与解释共存的语言</strong> 。</p>
<h3 id="为什么说-java-语言-编译与解释并存"> 为什么说 Java 语言“编译与解释并存”？</h3>
<p>这是因为 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（<code>.class</code> 文件），这种字节码必须由 Java 解释器来解释执行。</p>
<h3 id="java-和-c-的区别"> Java 和 C++ 的区别?</h3>
<ul>
<li>Java 不提供指针来直接访问内存，程序内存更加安全</li>
<li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li>
<li>Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。</li>
<li>C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。</li>
</ul>
]]></content:encoded>
      <enclosure url="https://snailclimb.gitee.io/javaguide/docs/java/basis/images/java%E7%A8%8B%E5%BA%8F%E8%BD%AC%E5%8F%98%E4%B8%BA%E6%9C%BA%E5%99%A8%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BF%87%E7%A8%8B.png" type="image/png"/>
    </item>
    <item>
      <title>博客主页</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">博客主页</source>
      <pubDate>Mon, 11 Apr 2022 16:35:43 GMT</pubDate>
    </item>
    <item>
      <title>基本语法</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95.html</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95.html</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">基本语法</source>
      <pubDate>Mon, 11 Apr 2022 16:35:43 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="基本语法"> 基本语法</h2>
<h3 id="字符型常量和字符串常量的区别"> 字符型常量和字符串常量的区别?</h3>
<ol>
<li>
<p><strong>形式</strong> : 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符。</p>
</li>
<li>
<p><strong>含义</strong> : 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)。</p>
</li>
<li>
<p><strong>占内存大小</strong> ： 字符常量只占 2 个字节; 字符串常量占若干个字节。</p>
<p>(<strong>注意： <code>char</code> 在 Java 中占两个字节</strong>)</p>
</li>
</ol>
<h4 id="静态方法为什么不能调用非静态成员"> 静态方法为什么不能调用非静态成员?</h4>
<ol>
<li>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</li>
<li>在类的非静态成员不存在的时候静态成员就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</li>
</ol>
<h4 id="重载和重写的区别"> 重载和重写的区别</h4>
<p><strong>重载</strong></p>
<p>发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</p>
<p><strong>重写</strong></p>
<p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p>
<ol>
<li>方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li>
<li>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 <code>static</code> 修饰的方法能够被再次声明。</li>
<li>构造方法无法被重写</li>
</ol>
<table>
<thead>
<tr>
<th>区别点</th>
<th>重载方法</th>
<th>重写方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>发生范围</td>
<td>同一个类</td>
<td>子类</td>
</tr>
<tr>
<td>参数列表</td>
<td>必须修改</td>
<td>一定不能修改</td>
</tr>
<tr>
<td>返回类型</td>
<td>可修改</td>
<td>子类方法返回值类型应比父类方法返回值类型更小或相等</td>
</tr>
<tr>
<td>异常</td>
<td>可修改</td>
<td>子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>可修改</td>
<td>一定不能做更严格的限制（可以降低限制）</td>
</tr>
<tr>
<td>发生阶段</td>
<td>编译期</td>
<td>运行期</td>
</tr>
</tbody>
</table>
<h3 id="什么是可变长参数"> 什么是可变长参数？</h3>
<p>方法就可以接受 0 个或者多个参数。另外，可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数。Java 的可变参数编译后实际会被转换成一个数组</p>
]]></content:encoded>
    </item>
    <item>
      <title>基本数据类型</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">基本数据类型</source>
      <pubDate>Mon, 11 Apr 2022 16:35:43 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="基本数据类型"> 基本数据类型</h2>
<p>Java 中有 8 种基本数据类型，分别为：</p>
<ul>
<li>6 种数字类型：
<ul>
<li>4 种整数型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li>
<li>2 种浮点型：<code>float</code>、<code>double</code></li>
</ul>
</li>
<li>1 种字符类型：<code>char</code></li>
<li>1 种布尔型：<code>boolean</code>。</li>
</ul>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>位数</th>
<th>字节</th>
<th>默认值</th>
<th>取值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>byte</code></td>
<td>8</td>
<td>1</td>
<td>0</td>
<td>-128 ~ 127</td>
</tr>
<tr>
<td><code>short</code></td>
<td>16</td>
<td>2</td>
<td>0</td>
<td>-32768 ~ 32767</td>
</tr>
<tr>
<td><code>int</code></td>
<td>32</td>
<td>4</td>
<td>0</td>
<td>-2147483648 ~ 2147483647</td>
</tr>
<tr>
<td><code>long</code></td>
<td>64</td>
<td>8</td>
<td>0L</td>
<td>-9223372036854775808 ~ 9223372036854775807</td>
</tr>
<tr>
<td><code>char</code></td>
<td>16</td>
<td>2</td>
<td>'u0000'</td>
<td>0 ~ 65535</td>
</tr>
<tr>
<td><code>float</code></td>
<td>32</td>
<td>4</td>
<td>0f</td>
<td>1.4E-45 ~ 3.4028235E38</td>
</tr>
<tr>
<td><code>double</code></td>
<td>64</td>
<td>8</td>
<td>0d</td>
<td>4.9E-324 ~ 1.7976931348623157E308</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td>1</td>
<td></td>
<td>false</td>
<td>true、false</td>
</tr>
</tbody>
</table>
<p><strong>注意：</strong></p>
<ol>
<li>Java 里使用 <code>long</code> 类型的数据一定要在数值后面加上 <strong>L</strong>，否则将作为整型解析。</li>
<li><code>char a = 'h'</code>char :单引号，<code>String a = &quot;hello&quot;</code> :双引号。</li>
</ol>
<p>这八种基本类型都有对应的包装类分别为：<code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Character</code>、<code>Boolean</code> 。</p>
<h3 id="基本类型和包装类型的区别"> 基本类型和包装类型的区别？</h3>
<ul>
<li>包装类型不赋值就是 <code>null</code> ，而基本类型有默认值且不是 <code>null</code>。</li>
<li>包装类型可用于泛型，而基本类型不可以。</li>
<li>基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。</li>
<li>相比于对象类型， 基本数据类型占用的空间非常小。</li>
</ul>
<h3 id="包装类型的常量池技术了解么"> 包装类型的常量池技术了解么？</h3>
<p>Java 基本类型的包装类的大部分都实现了常量池技术。</p>
<p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p>
<p>两种浮点数类型的包装类 <code>Float</code>,<code>Double</code> 并没有实现常量池技术。</p>
<h3 id="自动装箱与拆箱了解吗-原理是什么"> 自动装箱与拆箱了解吗？原理是什么？</h3>
<p><strong>什么是自动拆装箱？</strong></p>
<ul>
<li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li>
<li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li>
</ul>
<p>注意：<strong>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。</strong></p>
<div><pre><code><span>Integer</span> i <span>=</span> <span>10</span><span>;</span>  <span>//装箱</span>
<span>int</span> n <span>=</span> i<span>;</span>   <span>//拆箱</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>从字节码中，我们发现装箱其实就是调用了 包装类的<code>valueOf()</code>方法，拆箱其实就是调用了 <code>xxxValue()</code>方法。</p>
<p>因此，</p>
<ul>
<li><code>Integer i = 10</code> 等价于 <code>Integer i = Integer.valueOf(10)</code></li>
<li><code>int n = i</code> 等价于 <code>int n = i.intValue()</code>;</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>面向对象基础</title>
      <link>https://vuepress-theme-hope-demo.mrhope.site/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80.html</link>
      <guid>https://vuepress-theme-hope-demo.mrhope.site/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80.html</guid>
      <source url="https://vuepress-theme-hope-demo.mrhope.site/rss.xml">面向对象基础</source>
      <pubDate>Mon, 11 Apr 2022 16:35:43 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="面向对象基础"> 面向对象基础</h2>
<h3 id="面向对象和面向过程的区别"> 面向对象和面向过程的区别</h3>
<p>两者的主要区别在于解决问题的方式不同：</p>
<ul>
<li>面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li>
<li>面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。</li>
</ul>
<p>另外，面向对象开发的程序一般更易维护、易复用、易扩展。</p>
<h3 id="成员变量与局部变量的区别有哪些"> 成员变量与局部变量的区别有哪些？</h3>
<ul>
<li><strong>语法形式</strong> ：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code> 等修饰符所修饰，而局部变量不能被访问控制修饰符及 <code>static</code> 所修饰；但是，成员变量和局部变量都能被 <code>final</code> 所修饰。</li>
<li><strong>存储方式</strong> ：从变量在内存中的存储方式来看,如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</li>
<li><strong>生存时间</strong> ：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。</li>
<li><strong>默认值</strong> ：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 <code>final</code> 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</li>
</ul>
<h3 id="如果一个类没有声明构造方法-该程序能正确执行吗"> 如果一个类没有声明构造方法，该程序能正确执行吗?</h3>
<p>如果一个类没有声明构造方法，也可以执行！因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果我们自己添加了类的构造方法（无论是否有参），Java 就不会再添加默认的无参数的构造方法了，这时候，就不能直接 new 一个对象而不传递参数了，所以我们一直在不知不觉地使用构造方法，这也是为什么我们在创建对象的时候后面要加一个括号（因为要调用无参的构造方法）。如果我们重载了有参的构造方法，记得都要把无参的构造方法也写出来（无论是否用到），因为这可以帮助我们在创建对象的时候少踩坑。</p>
<h3 id="构造方法有哪些特点-是否可被-override"> 构造方法有哪些特点？是否可被 override?</h3>
<p>构造方法特点如下：</p>
<ul>
<li>名字与类名相同。</li>
<li>没有返回值，但不能用 void 声明构造函数。</li>
<li>生成类的对象时自动执行，无需调用。</li>
</ul>
<p>构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。</p>
<h3 id="面向对象三大特征"> 面向对象三大特征</h3>
<h4 id="封装"> 封装</h4>
<p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。</p>
<h4 id="继承"> 继承</h4>
<p><strong>关于继承如下 3 点请记住：</strong></p>
<ol>
<li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li>
<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法。（以后介绍）。</li>
</ol>
<h4 id="多态"> 多态</h4>
<p>多态，顾名思义，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</p>
<p><strong>多态的特点:</strong></p>
<ul>
<li>对象类型和引用类型之间具有继承（类）/实现（接口）的关系；</li>
<li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li>
<li>多态不能调用“只在子类存在但在父类不存在”的方法；</li>
<li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li>
</ul>
<h3 id="接口和抽象类有什么共同点和区别"> 接口和抽象类有什么共同点和区别？</h3>
<p><strong>共同点</strong> ：</p>
<ul>
<li>都不能被实例化。</li>
<li>都可以包含抽象方法。</li>
<li>都可以有默认实现的方法（Java 8 可以用 <code>default</code> 关键在接口中定义默认方法）。</li>
</ul>
<p><strong>区别</strong> ：</p>
<ul>
<li>接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系（比如说我们抽象了一个发送短信的抽象类，）。</li>
<li>一个类只能继承一个类，但是可以实现多个接口。</li>
<li>接口中的成员变量只能是 <code>public static final</code> 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。</li>
</ul>
<h3 id="深拷贝和浅拷贝区别了解吗-什么是引用拷贝"> 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？</h3>
<p>关于深拷贝和浅拷贝区别，我这里先给结论：</p>
<ul>
<li><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</li>
<li><strong>深拷贝</strong> ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</li>
</ul>
<p><img src="https://snailclimb.gitee.io/javaguide/docs/java/basis/images/shallow&amp;deep-copy.png" alt="img" loading="lazy"></p>
]]></content:encoded>
      <enclosure url="https://snailclimb.gitee.io/javaguide/docs/java/basis/images/shallow&deep-copy.png" type="image/png"/>
    </item>
  </channel>
</rss>