(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{543:function(v,_,t){"use strict";t.r(_);var a=t(1),s=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"面向对象基础"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#面向对象基础"}},[v._v("#")]),v._v(" 面向对象基础")]),v._v(" "),t("h3",{attrs:{id:"面向对象和面向过程的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#面向对象和面向过程的区别"}},[v._v("#")]),v._v(" 面向对象和面向过程的区别")]),v._v(" "),t("p",[v._v("两者的主要区别在于解决问题的方式不同：")]),v._v(" "),t("ul",[t("li",[v._v("面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。")]),v._v(" "),t("li",[v._v("面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。")])]),v._v(" "),t("p",[v._v("另外，面向对象开发的程序一般更易维护、易复用、易扩展。")]),v._v(" "),t("h3",{attrs:{id:"成员变量与局部变量的区别有哪些"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#成员变量与局部变量的区别有哪些"}},[v._v("#")]),v._v(" 成员变量与局部变量的区别有哪些？")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("语法形式")]),v._v(" ：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 "),t("code",[v._v("public")]),v._v(","),t("code",[v._v("private")]),v._v(","),t("code",[v._v("static")]),v._v(" 等修饰符所修饰，而局部变量不能被访问控制修饰符及 "),t("code",[v._v("static")]),v._v(" 所修饰；但是，成员变量和局部变量都能被 "),t("code",[v._v("final")]),v._v(" 所修饰。")]),v._v(" "),t("li",[t("strong",[v._v("存储方式")]),v._v(" ：从变量在内存中的存储方式来看,如果成员变量是使用 "),t("code",[v._v("static")]),v._v(" 修饰的，那么这个成员变量是属于类的，如果没有使用 "),t("code",[v._v("static")]),v._v(" 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。")]),v._v(" "),t("li",[t("strong",[v._v("生存时间")]),v._v(" ：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。")]),v._v(" "),t("li",[t("strong",[v._v("默认值")]),v._v(" ：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 "),t("code",[v._v("final")]),v._v(" 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。")])]),v._v(" "),t("h3",{attrs:{id:"如果一个类没有声明构造方法-该程序能正确执行吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如果一个类没有声明构造方法-该程序能正确执行吗"}},[v._v("#")]),v._v(" 如果一个类没有声明构造方法，该程序能正确执行吗?")]),v._v(" "),t("p",[v._v("如果一个类没有声明构造方法，也可以执行！因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果我们自己添加了类的构造方法（无论是否有参），Java 就不会再添加默认的无参数的构造方法了，这时候，就不能直接 new 一个对象而不传递参数了，所以我们一直在不知不觉地使用构造方法，这也是为什么我们在创建对象的时候后面要加一个括号（因为要调用无参的构造方法）。如果我们重载了有参的构造方法，记得都要把无参的构造方法也写出来（无论是否用到），因为这可以帮助我们在创建对象的时候少踩坑。")]),v._v(" "),t("h3",{attrs:{id:"构造方法有哪些特点-是否可被-override"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#构造方法有哪些特点-是否可被-override"}},[v._v("#")]),v._v(" 构造方法有哪些特点？是否可被 override?")]),v._v(" "),t("p",[v._v("构造方法特点如下：")]),v._v(" "),t("ul",[t("li",[v._v("名字与类名相同。")]),v._v(" "),t("li",[v._v("没有返回值，但不能用 void 声明构造函数。")]),v._v(" "),t("li",[v._v("生成类的对象时自动执行，无需调用。")])]),v._v(" "),t("p",[v._v("构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。")]),v._v(" "),t("h3",{attrs:{id:"面向对象三大特征"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#面向对象三大特征"}},[v._v("#")]),v._v(" 面向对象三大特征")]),v._v(" "),t("h4",{attrs:{id:"封装"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#封装"}},[v._v("#")]),v._v(" 封装")]),v._v(" "),t("p",[v._v("封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。")]),v._v(" "),t("h4",{attrs:{id:"继承"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#继承"}},[v._v("#")]),v._v(" 继承")]),v._v(" "),t("p",[t("strong",[v._v("关于继承如下 3 点请记住：")])]),v._v(" "),t("ol",[t("li",[v._v("子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，"),t("strong",[v._v("只是拥有")]),v._v("。")]),v._v(" "),t("li",[v._v("子类可以拥有自己属性和方法，即子类可以对父类进行扩展。")]),v._v(" "),t("li",[v._v("子类可以用自己的方式实现父类的方法。（以后介绍）。")])]),v._v(" "),t("h4",{attrs:{id:"多态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多态"}},[v._v("#")]),v._v(" 多态")]),v._v(" "),t("p",[v._v("多态，顾名思义，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。")]),v._v(" "),t("p",[t("strong",[v._v("多态的特点:")])]),v._v(" "),t("ul",[t("li",[v._v("对象类型和引用类型之间具有继承（类）/实现（接口）的关系；")]),v._v(" "),t("li",[v._v("引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；")]),v._v(" "),t("li",[v._v("多态不能调用“只在子类存在但在父类不存在”的方法；")]),v._v(" "),t("li",[v._v("如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。")])]),v._v(" "),t("h3",{attrs:{id:"接口和抽象类有什么共同点和区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#接口和抽象类有什么共同点和区别"}},[v._v("#")]),v._v(" 接口和抽象类有什么共同点和区别？")]),v._v(" "),t("p",[t("strong",[v._v("共同点")]),v._v(" ：")]),v._v(" "),t("ul",[t("li",[v._v("都不能被实例化。")]),v._v(" "),t("li",[v._v("都可以包含抽象方法。")]),v._v(" "),t("li",[v._v("都可以有默认实现的方法（Java 8 可以用 "),t("code",[v._v("default")]),v._v(" 关键在接口中定义默认方法）。")])]),v._v(" "),t("p",[t("strong",[v._v("区别")]),v._v(" ：")]),v._v(" "),t("ul",[t("li",[v._v("接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系（比如说我们抽象了一个发送短信的抽象类，）。")]),v._v(" "),t("li",[v._v("一个类只能继承一个类，但是可以实现多个接口。")]),v._v(" "),t("li",[v._v("接口中的成员变量只能是 "),t("code",[v._v("public static final")]),v._v(" 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。")])]),v._v(" "),t("h3",{attrs:{id:"深拷贝和浅拷贝区别了解吗-什么是引用拷贝"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#深拷贝和浅拷贝区别了解吗-什么是引用拷贝"}},[v._v("#")]),v._v(" 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？")]),v._v(" "),t("p",[v._v("关于深拷贝和浅拷贝区别，我这里先给结论：")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("浅拷贝")]),v._v("：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。")]),v._v(" "),t("li",[t("strong",[v._v("深拷贝")]),v._v(" ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。")])]),v._v(" "),t("p",[t("img",{attrs:{src:"https://snailclimb.gitee.io/javaguide/docs/java/basis/images/shallow&deep-copy.png",alt:"img",loading:"lazy"}})])])}),[],!1,null,null,null);_.default=s.exports}}]);